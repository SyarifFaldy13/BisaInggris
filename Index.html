(function () {
    const container = document.querySelector('#testimoni .testimonials-container');
    if (!container) return;

    const existingGrid = container.querySelector('.testimonial-grid');
    if (!existingGrid) return;

    // collect cards and remove original grid
    const cards = Array.from(existingGrid.children).map(c => c.cloneNode(true));
    existingGrid.remove();

    // build slider + track
    const slider = document.createElement('div');
    slider.className = 'testimonial-slider';
    const track = document.createElement('div');
    track.className = 'testimonial-track';

    // append two copies for seamless loop
    cards.forEach(c => track.appendChild(c.cloneNode(true)));
    cards.forEach(c => track.appendChild(c.cloneNode(true)));

    slider.appendChild(track);
    container.appendChild(slider);

    // inject CSS for slider/track
    const style = document.createElement('style');
    style.textContent = `
        .testimonial-slider { width:100%; overflow:hidden; position:relative; padding: 12px 0; }
        .testimonial-track { display:flex; gap:24px; align-items:stretch; will-change: transform; }
        .testimonial-track .testimonial-card { flex: 0 0 auto; }
        @media (max-width:767px) { .testimonial-track { gap:12px; } .testimonial-track .testimonial-card { width: calc(100% - 48px); max-width: 420px; } }
        @media (prefers-reduced-motion: reduce) { .testimonial-track { animation: none !important; } }
    `;
    document.head.appendChild(style);

    // animation loop (left -> right). uses pixels/sec speed
    let speed = 40; // px per second (adjustable)
    let pos = 0;
    let singleWidth = 0;
    let last = performance.now();
    let paused = false;

    function recalc() {
        // total track width / 2 = width of one set
        singleWidth = track.scrollWidth / 2 || 0;
        // start from -singleWidth so first visible set scrolls into view left->right
        pos = -singleWidth;
        track.style.transform = `translateX(${pos}px)`;
    }

    // continuous animation: move right (increase pos). when reaches 0, reset to -singleWidth
    function tick(now) {
        if (paused) { last = now; requestAnimationFrame(tick); return; }
        const dt = Math.max(0, now - last) / 1000;
        last = now;
        pos += speed * dt;
        if (pos >= 0) pos = -singleWidth + (pos - 0); // wrap smoothly
        track.style.transform = `translateX(${pos}px)`;
        requestAnimationFrame(tick);
    }

    // pause on hover
    slider.addEventListener('mouseenter', () => paused = true);
    slider.addEventListener('mouseleave', () => paused = false);

    // recalc on load/resize
    window.addEventListener('load', () => { recalc(); last = performance.now(); requestAnimationFrame(tick); });
    window.addEventListener('resize', () => { recalc(); });
    // initial calc
    recalc();
})();
